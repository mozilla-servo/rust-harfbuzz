#![allow(non_camel_case_types)]

#![cfg_attr(feature = "cargo-clippy", allow(unreadable_literal))]

#[cfg(any(target_os = "android", all(unix, not(target_os = "macos"))))]
extern crate freetype;

#[cfg(any(target_os = "android", all(unix, not(target_os = "macos"))))]
extern "C" {
    pub fn hb_ft_font_create_referenced(face: freetype::freetype::FT_Face) -> *mut hb_font_t;
}

/* automatically generated by rust-bindgen */

pub const HB_UNICODE_MAX_DECOMPOSITION_LEN: ::std::os::raw::c_uint = 19;
pub const HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT: ::std::os::raw::c_uint = 65533;
pub const HB_OT_LAYOUT_NO_SCRIPT_INDEX: ::std::os::raw::c_uint = 65535;
pub const HB_OT_LAYOUT_NO_FEATURE_INDEX: ::std::os::raw::c_uint = 65535;
pub const HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX: ::std::os::raw::c_uint = 65535;
pub const HB_OT_LAYOUT_NO_VARIATIONS_INDEX: ::std::os::raw::c_uint = 4294967295;
pub const HB_OT_VAR_NO_AXIS_INDEX: ::std::os::raw::c_uint = 4294967295;
pub type hb_bool_t = ::std::os::raw::c_int;
pub type hb_codepoint_t = u32;
pub type hb_position_t = i32;
pub type hb_mask_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _hb_var_int_t {
    pub u32: u32,
    pub i32: i32,
    pub u16: [u16; 2usize],
    pub i16: [i16; 2usize],
    pub u8: [u8; 4usize],
    pub i8: [i8; 4usize],
    _bindgen_union_align: u32,
}
#[allow(non_snake_case)]
#[test]
fn bindgen_test_layout__hb_var_int_t() {
    assert_eq!(
        ::std::mem::size_of::<_hb_var_int_t>(),
        4usize,
        concat!("Size of: ", stringify!(_hb_var_int_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_hb_var_int_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_hb_var_int_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_hb_var_int_t>())).u32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(u32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_hb_var_int_t>())).i32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(i32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_hb_var_int_t>())).u16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(u16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_hb_var_int_t>())).i16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(i16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_hb_var_int_t>())).u8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(u8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_hb_var_int_t>())).i8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(i8)
        )
    );
}
impl ::std::fmt::Debug for _hb_var_int_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "_hb_var_int_t {{ ... }}")
    }
}
pub type hb_var_int_t = _hb_var_int_t;
pub type hb_tag_t = u32;
extern "C" {
    pub fn hb_tag_from_string(
        str: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_tag_t;
}
extern "C" {
    pub fn hb_tag_to_string(tag: hb_tag_t, buf: *mut ::std::os::raw::c_char);
}

#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Direction {
    /// Initial, unset direction.
    Invalid = 0,
    /// Text is set horizontally from left to right.
    LTR = 4,
    /// Text is set horizontally from right to left.
    RTL = 5,
    /// Text is set vertically from top to bottom.
    TTB = 6,
    /// Text is set vertically from bottom to top.
    BTT = 7,
}
pub type hb_direction_t = Direction;

extern "C" {
    pub fn hb_direction_from_string(
        str: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_direction_t;
}
extern "C" {
    pub fn hb_direction_to_string(direction: hb_direction_t) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_language_impl_t {
    _unused: [u8; 0],
}
pub type hb_language_t = *const hb_language_impl_t;
extern "C" {
    pub fn hb_language_from_string(
        str: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_language_t;
}
extern "C" {
    pub fn hb_language_to_string(language: hb_language_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_language_get_default() -> hb_language_t;
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Script {
    Common = 1517910393,
    Inherited = 1516858984,
    Unknown = 1517976186,
    Arabic = 1098015074,
    Armenian = 1098018158,
    Bengali = 1113943655,
    Cyrillic = 1132032620,
    Devanagari = 1147500129,
    Georgian = 1197830002,
    Greek = 1198679403,
    Gujarati = 1198877298,
    Gurmukhi = 1198879349,
    Hangul = 1214344807,
    Han = 1214344809,
    Hebrew = 1214603890,
    Hiragana = 1214870113,
    Kannada = 1265525857,
    Katakana = 1264676449,
    LAO = 1281453935,
    Latin = 1281455214,
    Malayalam = 1298954605,
    Oriya = 1332902241,
    Tamil = 1415671148,
    Telugu = 1415933045,
    Thai = 1416126825,
    Tibetan = 1416192628,
    Bopomofo = 1114599535,
    Braille = 1114792297,
    CanadianSyllabics = 1130458739,
    Cherokee = 1130915186,
    Ethiopic = 1165256809,
    Khmer = 1265134962,
    Mongolian = 1299148391,
    Myanmar = 1299803506,
    Ogham = 1332175213,
    Runic = 1383427698,
    Sinhala = 1399418472,
    Syriac = 1400468067,
    Thaana = 1416126817,
    Yi = 1500080489,
    Deseret = 1148416628,
    Gothic = 1198486632,
    OldItalic = 1232363884,
    Buhid = 1114990692,
    Hanunoo = 1214344815,
    Tagalog = 1416064103,
    Tagbanwa = 1415669602,
    Cypriot = 1131442804,
    Limbu = 1281977698,
    LinearB = 1281977954,
    Osmanya = 1332964705,
    Shavian = 1399349623,
    TaiLe = 1415670885,
    Ugaritic = 1432838514,
    Buginese = 1114990441,
    Coptic = 1131376756,
    Glagolitic = 1198285159,
    Kharoshthi = 1265131890,
    NewTaiLue = 1415670901,
    OldPersian = 1483761007,
    SylotiNagri = 1400466543,
    Tifinagh = 1415999079,
    Balinese = 1113681001,
    Cuneiform = 1483961720,
    Nko = 1315663727,
    PhagsPa = 1349017959,
    Phoenician = 1349021304,
    Carian = 1130459753,
    Cham = 1130914157,
    KayahLi = 1264675945,
    Lepcha = 1281716323,
    Lycian = 1283023721,
    Lydian = 1283023977,
    OlChiki = 1332503403,
    Rejang = 1382706791,
    Saurashtra = 1398895986,
    Sundanese = 1400204900,
    Vai = 1449224553,
    Avestan = 1098281844,
    Bamum = 1113681269,
    EgyptianHieroglyphs = 1164409200,
    ImperialAramaic = 1098018153,
    InscriptionalPahlavi = 1349020777,
    InscriptionalParthian = 1349678185,
    Javanese = 1247901281,
    Kaithi = 1265920105,
    Lisu = 1281979253,
    MeeteiMayek = 1299473769,
    OldSouthArabian = 1398895202,
    OldTurkic = 1332898664,
    Samaritan = 1398893938,
    TaiTham = 1281453665,
    TaiViet = 1415673460,
    Batak = 1113683051,
    Brahmi = 1114792296,
    Mandaic = 1298230884,
    Chakma = 1130457965,
    MeroiticCursive = 1298494051,
    MeroiticHieroglyphs = 1298494063,
    Miao = 1349284452,
    Sharada = 1399353956,
    SoraSompeng = 1399812705,
    Takri = 1415670642,
    BassaVah = 1113682803,
    CaucasianAlbanian = 1097295970,
    Duployan = 1148547180,
    Elbasan = 1164730977,
    Grantha = 1198678382,
    Khojki = 1265135466,
    Khudawadi = 1399418468,
    LinearA = 1281977953,
    Mahajani = 1298229354,
    Manichaean = 1298230889,
    MendeKikakui = 1298493028,
    Modi = 1299145833,
    Mro = 1299345263,
    Nabataean = 1315070324,
    OldNorthArabian = 1315009122,
    OldPermic = 1348825709,
    PahawhHmong = 1215131239,
    Palmyrene = 1348562029,
    PauCinHau = 1348564323,
    PsalterPahlavi = 1349020784,
    Siddham = 1399415908,
    Tirhuta = 1416196712,
    WarangCiti = 1466004065,
    Ahom = 1097363309,
    AnatolianHieroglyphs = 1215067511,
    Hatran = 1214346354,
    Multani = 1299541108,
    OldHungarian = 1215655527,
    Signwriting = 1399287415,
    Adlam = 1097100397,
    Bhaiksuki = 1114139507,
    Marchen = 1298231907,
    Osage = 1332963173,
    Tangut = 1415671399,
    Newa = 1315272545,
    MasaramGondi = 1198485101,
    Nushu = 1316186229,
    Soyombo = 1399814511,
    ZanabazarSquare = 1516334690,
    Invalid = 0,
}
pub type hb_script_t = Script;
extern "C" {
    pub fn hb_script_from_iso15924_tag(tag: hb_tag_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_script_from_string(
        str: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_script_t;
}
extern "C" {
    pub fn hb_script_to_iso15924_tag(script: hb_script_t) -> hb_tag_t;
}
extern "C" {
    pub fn hb_script_get_horizontal_direction(script: hb_script_t) -> hb_direction_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_user_data_key_t {
    pub unused: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hb_user_data_key_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_user_data_key_t>(),
        1usize,
        concat!("Size of: ", stringify!(hb_user_data_key_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_user_data_key_t>(),
        1usize,
        concat!("Alignment of ", stringify!(hb_user_data_key_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_user_data_key_t>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_user_data_key_t),
            "::",
            stringify!(unused)
        )
    );
}
pub type hb_destroy_func_t =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_feature_t {
    pub tag: hb_tag_t,
    pub value: u32,
    pub start: ::std::os::raw::c_uint,
    pub end: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hb_feature_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_feature_t>(),
        16usize,
        concat!("Size of: ", stringify!(hb_feature_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_feature_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_feature_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_feature_t>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_feature_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_feature_t>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_feature_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_feature_t>())).start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_feature_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_feature_t>())).end as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_feature_t),
            "::",
            stringify!(end)
        )
    );
}
extern "C" {
    pub fn hb_feature_from_string(
        str: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        feature: *mut hb_feature_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_feature_to_string(
        feature: *mut hb_feature_t,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}

/// hb_variation_t:
///
/// Since: 1.4.2
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_variation_t {
    pub tag: hb_tag_t,
    pub value: f32,
}
#[test]
fn bindgen_test_layout_hb_variation_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_variation_t>(),
        8usize,
        concat!("Size of: ", stringify!(hb_variation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_variation_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_variation_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_variation_t>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_variation_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_variation_t>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_variation_t),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn hb_variation_from_string(
        str: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        variation: *mut hb_variation_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_variation_to_string(
        variation: *mut hb_variation_t,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MemoryMode {
    Duplicate = 0,
    ReadOnly = 1,
    Writable = 2,
    ReadOnlyMayMakeWritable = 3,
}
pub type hb_memory_mode_t = MemoryMode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_blob_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_blob_create(
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
        mode: hb_memory_mode_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_create_sub_blob(
        parent: *mut hb_blob_t,
        offset: ::std::os::raw::c_uint,
        length: ::std::os::raw::c_uint,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_get_empty() -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_reference(blob: *mut hb_blob_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_destroy(blob: *mut hb_blob_t);
}
extern "C" {
    pub fn hb_blob_set_user_data(
        blob: *mut hb_blob_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_blob_get_user_data(
        blob: *mut hb_blob_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_blob_make_immutable(blob: *mut hb_blob_t);
}
extern "C" {
    pub fn hb_blob_is_immutable(blob: *mut hb_blob_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_blob_get_length(blob: *mut hb_blob_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_blob_get_data(
        blob: *mut hb_blob_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_blob_get_data_writable(
        blob: *mut hb_blob_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum UnicodeGeneralCategory {
    Control = 0,
    Format = 1,
    Unassigned = 2,
    PrivateUse = 3,
    Surrogate = 4,
    LowercaseLetter = 5,
    ModifierLetter = 6,
    OtherLetter = 7,
    TitlecaseLetter = 8,
    UppercaseLetter = 9,
    SpacingMark = 10,
    EnclosingMark = 11,
    NonSpacingMark = 12,
    DecimalNumber = 13,
    LetterNumber = 14,
    OtherNumber = 15,
    ConnectPunctuation = 16,
    DashPunctuation = 17,
    ClosePunctuation = 18,
    FinalPunctuation = 19,
    InitialPunctuation = 20,
    OtherPunctuation = 21,
    OpenPunctuation = 22,
    CurrencySymbol = 23,
    ModifierSymbol = 24,
    MathSymbol = 25,
    OtherSymbol = 26,
    LineSeparator = 27,
    ParagraphSeparator = 28,
    SpaceSeparator = 29,
}
pub type hb_unicode_general_category_t = UnicodeGeneralCategory;
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum UnicodeCombiningClass {
    NotReordered = 0,
    Overlay = 1,
    Nukta = 7,
    KanaVoicing = 8,
    Virama = 9,
    CCC10 = 10,
    CCC11 = 11,
    CCC12 = 12,
    CCC13 = 13,
    CCC14 = 14,
    CCC15 = 15,
    CCC16 = 16,
    CCC17 = 17,
    CCC18 = 18,
    CCC19 = 19,
    CCC20 = 20,
    CCC21 = 21,
    CCC22 = 22,
    CCC23 = 23,
    CCC24 = 24,
    CCC25 = 25,
    CCC26 = 26,
    CCC27 = 27,
    CCC28 = 28,
    CCC29 = 29,
    CCC30 = 30,
    CCC31 = 31,
    CCC32 = 32,
    CCC33 = 33,
    CCC34 = 34,
    CCC35 = 35,
    CCC36 = 36,
    CCC84 = 84,
    CCC91 = 91,
    CCC103 = 103,
    CCC107 = 107,
    CCC118 = 118,
    CCC122 = 122,
    CCC129 = 129,
    CCC130 = 130,
    CCC133 = 132,
    AttachedBelowLeft = 200,
    AttachedBelow = 202,
    AttachedAbove = 214,
    AttachedAboveRight = 216,
    BelowLeft = 218,
    Below = 220,
    BelowRight = 222,
    Left = 224,
    Right = 226,
    AboveLeft = 228,
    Above = 230,
    AboveRight = 232,
    DoubleBelow = 233,
    DoubleAbove = 234,
    IotaSubscript = 240,
    Invalid = 255,
}
pub type hb_unicode_combining_class_t = UnicodeCombiningClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_unicode_funcs_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_unicode_funcs_get_default() -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_create(parent: *mut hb_unicode_funcs_t) -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_empty() -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_reference(ufuncs: *mut hb_unicode_funcs_t) -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_destroy(ufuncs: *mut hb_unicode_funcs_t);
}
extern "C" {
    pub fn hb_unicode_funcs_set_user_data(
        ufuncs: *mut hb_unicode_funcs_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_user_data(
        ufuncs: *mut hb_unicode_funcs_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_unicode_funcs_make_immutable(ufuncs: *mut hb_unicode_funcs_t);
}
extern "C" {
    pub fn hb_unicode_funcs_is_immutable(ufuncs: *mut hb_unicode_funcs_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_parent(ufuncs: *mut hb_unicode_funcs_t) -> *mut hb_unicode_funcs_t;
}
pub type hb_unicode_combining_class_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_unicode_combining_class_t,
>;
pub type hb_unicode_eastasian_width_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint,
>;
pub type hb_unicode_general_category_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_unicode_general_category_t,
>;
pub type hb_unicode_mirroring_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_codepoint_t,
>;
pub type hb_unicode_script_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_script_t,
>;
pub type hb_unicode_compose_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        a: hb_codepoint_t,
        b: hb_codepoint_t,
        ab: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
pub type hb_unicode_decompose_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        ab: hb_codepoint_t,
        a: *mut hb_codepoint_t,
        b: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
///
/// hb_unicode_decompose_compatibility_func_t:
/// @ufuncs: a Unicode function structure
/// @u: codepoint to decompose
/// @decomposed: address of codepoint array (of length %HB_UNICODE_MAX_DECOMPOSITION_LEN) to write decomposition into
/// @user_data: user data pointer as passed to hb_unicode_funcs_set_decompose_compatibility_func()
///
/// Fully decompose @u to its Unicode compatibility decomposition. The codepoints of the decomposition will be written to @decomposed.
/// The complete length of the decomposition will be returned.
///
/// If @u has no compatibility decomposition, zero should be returned.
///
/// The Unicode standard guarantees that a buffer of length %HB_UNICODE_MAX_DECOMPOSITION_LEN codepoints will always be sufficient for any
/// compatibility decomposition plus an terminating value of 0.  Consequently, @decompose must be allocated by the caller to be at least this length.  Implementations
/// of this function type must ensure that they do not write past the provided array.
///
/// Return value: number of codepoints in the full compatibility decomposition of @u, or 0 if no decomposition available.
pub type hb_unicode_decompose_compatibility_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        u: hb_codepoint_t,
        decomposed: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint,
>;
extern "C" {
    /// hb_unicode_funcs_set_combining_class_func:
    /// @ufuncs: a Unicode function structure
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_unicode_funcs_set_combining_class_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_combining_class_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_unicode_funcs_set_eastasian_width_func:
    /// @ufuncs: a Unicode function structure
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_unicode_funcs_set_eastasian_width_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_eastasian_width_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_unicode_funcs_set_general_category_func:
    /// @ufuncs: a Unicode function structure
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_unicode_funcs_set_general_category_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_general_category_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_unicode_funcs_set_mirroring_func:
    /// @ufuncs: a Unicode function structure
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_unicode_funcs_set_mirroring_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_mirroring_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_unicode_funcs_set_script_func:
    /// @ufuncs: a Unicode function structure
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_unicode_funcs_set_script_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_script_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_unicode_funcs_set_compose_func:
    /// @ufuncs: a Unicode function structure
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_unicode_funcs_set_compose_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_compose_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_unicode_funcs_set_decompose_func:
    /// @ufuncs: a Unicode function structure
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_unicode_funcs_set_decompose_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_decompose_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_unicode_funcs_set_decompose_compatibility_func:
    /// @ufuncs: a Unicode function structure
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_unicode_funcs_set_decompose_compatibility_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_decompose_compatibility_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_unicode_combining_class:
    ///
    /// Since: 0.9.2
    pub fn hb_unicode_combining_class(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_unicode_combining_class_t;
}
extern "C" {
    /// hb_unicode_eastasian_width:
    ///
    /// Since: 0.9.2
    pub fn hb_unicode_eastasian_width(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    /// hb_unicode_general_category:
    ///
    /// Since: 0.9.2
    pub fn hb_unicode_general_category(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_unicode_general_category_t;
}
extern "C" {
    /// hb_unicode_mirroring:
    ///
    /// Since: 0.9.2
    pub fn hb_unicode_mirroring(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_codepoint_t;
}
extern "C" {
    /// hb_unicode_script:
    ///
    /// Since: 0.9.2
    pub fn hb_unicode_script(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_script_t;
}
extern "C" {
    pub fn hb_unicode_compose(
        ufuncs: *mut hb_unicode_funcs_t,
        a: hb_codepoint_t,
        b: hb_codepoint_t,
        ab: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_decompose(
        ufuncs: *mut hb_unicode_funcs_t,
        ab: hb_codepoint_t,
        a: *mut hb_codepoint_t,
        b: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_decompose_compatibility(
        ufuncs: *mut hb_unicode_funcs_t,
        u: hb_codepoint_t,
        decomposed: *mut hb_codepoint_t,
    ) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_face_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_face_create(blob: *mut hb_blob_t, index: ::std::os::raw::c_uint) -> *mut hb_face_t;
}
pub type hb_reference_table_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        face: *mut hb_face_t,
        tag: hb_tag_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut hb_blob_t,
>;
extern "C" {
    pub fn hb_face_create_for_tables(
        reference_table_func: hb_reference_table_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    ) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_get_empty() -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_reference(face: *mut hb_face_t) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_destroy(face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_face_set_user_data(
        face: *mut hb_face_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_face_get_user_data(
        face: *mut hb_face_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_face_make_immutable(face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_face_is_immutable(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_face_reference_table(face: *mut hb_face_t, tag: hb_tag_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_face_reference_blob(face: *mut hb_face_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_face_set_index(face: *mut hb_face_t, index: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_index(face: *mut hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_set_upem(face: *mut hb_face_t, upem: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_upem(face: *mut hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_set_glyph_count(face: *mut hb_face_t, glyph_count: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_glyph_count(face: *mut hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_get_table_tags(
        face: *mut hb_face_t,
        start_offset: ::std::os::raw::c_uint,
        table_count: *mut ::std::os::raw::c_uint,
        table_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_funcs_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_font_funcs_create() -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_get_empty() -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_reference(ffuncs: *mut hb_font_funcs_t) -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_destroy(ffuncs: *mut hb_font_funcs_t);
}
extern "C" {
    pub fn hb_font_funcs_set_user_data(
        ffuncs: *mut hb_font_funcs_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_funcs_get_user_data(
        ffuncs: *mut hb_font_funcs_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_font_funcs_make_immutable(ffuncs: *mut hb_font_funcs_t);
}
extern "C" {
    pub fn hb_font_funcs_is_immutable(ffuncs: *mut hb_font_funcs_t) -> hb_bool_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_extents_t {
    pub ascender: hb_position_t,
    pub descender: hb_position_t,
    pub line_gap: hb_position_t,
    pub reserved9: hb_position_t,
    pub reserved8: hb_position_t,
    pub reserved7: hb_position_t,
    pub reserved6: hb_position_t,
    pub reserved5: hb_position_t,
    pub reserved4: hb_position_t,
    pub reserved3: hb_position_t,
    pub reserved2: hb_position_t,
    pub reserved1: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_font_extents_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_font_extents_t>(),
        48usize,
        concat!("Size of: ", stringify!(hb_font_extents_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_font_extents_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_font_extents_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_font_extents_t>())).ascender as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(ascender)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_font_extents_t>())).descender as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(descender)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_font_extents_t>())).line_gap as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(line_gap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_font_extents_t>())).reserved9 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_font_extents_t>())).reserved8 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_font_extents_t>())).reserved7 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_font_extents_t>())).reserved6 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_font_extents_t>())).reserved5 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_font_extents_t>())).reserved4 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_font_extents_t>())).reserved3 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_font_extents_t>())).reserved2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_font_extents_t>())).reserved1 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_glyph_extents_t {
    pub x_bearing: hb_position_t,
    pub y_bearing: hb_position_t,
    pub width: hb_position_t,
    pub height: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_extents_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_glyph_extents_t>(),
        16usize,
        concat!("Size of: ", stringify!(hb_glyph_extents_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_glyph_extents_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_glyph_extents_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_extents_t>())).x_bearing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_extents_t),
            "::",
            stringify!(x_bearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_extents_t>())).y_bearing as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_extents_t),
            "::",
            stringify!(y_bearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_extents_t>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_extents_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_extents_t>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_extents_t),
            "::",
            stringify!(height)
        )
    );
}
pub type hb_font_get_font_extents_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        metrics: *mut hb_font_extents_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
pub type hb_font_get_font_h_extents_func_t = hb_font_get_font_extents_func_t;
pub type hb_font_get_font_v_extents_func_t = hb_font_get_font_extents_func_t;
pub type hb_font_get_nominal_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        unicode: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
pub type hb_font_get_variation_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
pub type hb_font_get_glyph_advance_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_position_t,
>;
pub type hb_font_get_glyph_h_advance_func_t = hb_font_get_glyph_advance_func_t;
pub type hb_font_get_glyph_v_advance_func_t = hb_font_get_glyph_advance_func_t;
pub type hb_font_get_glyph_origin_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
pub type hb_font_get_glyph_h_origin_func_t = hb_font_get_glyph_origin_func_t;
pub type hb_font_get_glyph_v_origin_func_t = hb_font_get_glyph_origin_func_t;
pub type hb_font_get_glyph_kerning_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        first_glyph: hb_codepoint_t,
        second_glyph: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_position_t,
>;
pub type hb_font_get_glyph_h_kerning_func_t = hb_font_get_glyph_kerning_func_t;
pub type hb_font_get_glyph_v_kerning_func_t = hb_font_get_glyph_kerning_func_t;
pub type hb_font_get_glyph_extents_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        extents: *mut hb_glyph_extents_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
pub type hb_font_get_glyph_contour_point_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        point_index: ::std::os::raw::c_uint,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
pub type hb_font_get_glyph_name_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        name: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
pub type hb_font_get_glyph_from_name_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
extern "C" {
    /// hb_font_funcs_set_font_h_extents_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 1.1.2
    pub fn hb_font_funcs_set_font_h_extents_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_font_h_extents_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_font_funcs_set_font_v_extents_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 1.1.2
    pub fn hb_font_funcs_set_font_v_extents_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_font_v_extents_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_font_funcs_set_nominal_glyph_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 1.2.3
    pub fn hb_font_funcs_set_nominal_glyph_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_nominal_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_font_funcs_set_variation_glyph_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 1.2.3
    pub fn hb_font_funcs_set_variation_glyph_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_variation_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_font_funcs_set_glyph_h_advance_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_h_advance_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_advance_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_font_funcs_set_glyph_v_advance_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_v_advance_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_advance_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_font_funcs_set_glyph_h_origin_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_h_origin_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_origin_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_font_funcs_set_glyph_v_origin_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_v_origin_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_origin_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_font_funcs_set_glyph_h_kerning_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_h_kerning_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_kerning_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_font_funcs_set_glyph_v_kerning_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_v_kerning_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_kerning_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_font_funcs_set_glyph_extents_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_extents_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_extents_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_font_funcs_set_glyph_contour_point_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_contour_point_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_contour_point_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_font_funcs_set_glyph_name_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_name_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_name_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    /// hb_font_funcs_set_glyph_from_name_func:
    /// @ffuncs: font functions.
    /// @func: (closure user_data) (destroy destroy) (scope notified):
    /// @user_data:
    /// @destroy:
    ///
    ///
    ///
    /// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_from_name_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_from_name_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_get_h_extents(
        font: *mut hb_font_t,
        extents: *mut hb_font_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_v_extents(
        font: *mut hb_font_t,
        extents: *mut hb_font_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_nominal_glyph(
        font: *mut hb_font_t,
        unicode: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_variation_glyph(
        font: *mut hb_font_t,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_h_advance(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_v_advance(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_h_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_v_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_h_kerning(
        font: *mut hb_font_t,
        left_glyph: hb_codepoint_t,
        right_glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_v_kerning(
        font: *mut hb_font_t,
        top_glyph: hb_codepoint_t,
        bottom_glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_extents(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        extents: *mut hb_glyph_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_contour_point(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        point_index: ::std::os::raw::c_uint,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_name(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        name: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_from_name(
        font: *mut hb_font_t,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph(
        font: *mut hb_font_t,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_extents_for_direction(
        font: *mut hb_font_t,
        direction: hb_direction_t,
        extents: *mut hb_font_extents_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_advance_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_origin_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_add_glyph_origin_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_subtract_glyph_origin_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_kerning_for_direction(
        font: *mut hb_font_t,
        first_glyph: hb_codepoint_t,
        second_glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_extents_for_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        extents: *mut hb_glyph_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_contour_point_for_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        point_index: ::std::os::raw::c_uint,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_glyph_to_string(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        s: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_glyph_from_string(
        font: *mut hb_font_t,
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_create(face: *mut hb_face_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_create_sub_font(parent: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_get_empty() -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_reference(font: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_destroy(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_set_user_data(
        font: *mut hb_font_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_user_data(
        font: *mut hb_font_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_font_make_immutable(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_is_immutable(font: *mut hb_font_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_set_parent(font: *mut hb_font_t, parent: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_get_parent(font: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_set_face(font: *mut hb_font_t, face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_font_get_face(font: *mut hb_font_t) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_font_set_funcs(
        font: *mut hb_font_t,
        klass: *mut hb_font_funcs_t,
        font_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_set_funcs_data(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_set_scale(
        font: *mut hb_font_t,
        x_scale: ::std::os::raw::c_int,
        y_scale: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_font_get_scale(
        font: *mut hb_font_t,
        x_scale: *mut ::std::os::raw::c_int,
        y_scale: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_font_set_ppem(
        font: *mut hb_font_t,
        x_ppem: ::std::os::raw::c_uint,
        y_ppem: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_ppem(
        font: *mut hb_font_t,
        x_ppem: *mut ::std::os::raw::c_uint,
        y_ppem: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_set_ptem(font: *mut hb_font_t, ptem: f32);
}
extern "C" {
    pub fn hb_font_get_ptem(font: *mut hb_font_t) -> f32;
}
extern "C" {
    pub fn hb_font_set_variations(
        font: *mut hb_font_t,
        variations: *const hb_variation_t,
        variations_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_set_var_coords_design(
        font: *mut hb_font_t,
        coords: *const f32,
        coords_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_set_var_coords_normalized(
        font: *mut hb_font_t,
        coords: *const ::std::os::raw::c_int,
        coords_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_var_coords_normalized(
        font: *mut hb_font_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_int;
}
/// hb_glyph_info_t:
/// @codepoint: either a Unicode code point (before shaping) or a glyph index
///             (after shaping).
/// @mask:
/// @cluster: the index of the character in the original text that corresponds
///           to this `hb_glyph_info_t`, or whatever the client passes to
///           hb_buffer_add(). More than one `hb_glyph_info_t` can have the same
///           @cluster value, if they resulted from the same character (e.g. one
///           to many glyph substitution), and when more than one character gets
///           merged in the same glyph (e.g. many to one glyph substitution) the
///           `hb_glyph_info_t` will have the smallest cluster value of them.
///           By default some characters are merged into the same cluster
///           (e.g. combining marks have the same cluster as their bases)
///           even if they are separate glyphs, hb_buffer_set_cluster_level()
///           allow selecting more fine-grained cluster handling.
///
/// The `hb_glyph_info_t` is the structure that holds information about the
/// glyphs and their relation to input text.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_glyph_info_t {
    pub codepoint: hb_codepoint_t,
    pub mask: hb_mask_t,
    pub cluster: u32,
    pub var1: hb_var_int_t,
    pub var2: hb_var_int_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_info_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_glyph_info_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_glyph_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_glyph_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_glyph_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_info_t>())).codepoint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(codepoint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_info_t>())).mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_info_t>())).cluster as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(cluster)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_info_t>())).var1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(var1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_info_t>())).var2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(var2)
        )
    );
}
pub const HB_GLYPH_FLAG_DEFINED: hb_glyph_flags_t = hb_glyph_flags_t::HB_GLYPH_FLAG_UNSAFE_TO_BREAK;
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_glyph_flags_t {
    HB_GLYPH_FLAG_UNSAFE_TO_BREAK = 1,
}
extern "C" {
    pub fn hb_glyph_info_get_glyph_flags(info: *const hb_glyph_info_t) -> hb_glyph_flags_t;
}
/// hb_glyph_position_t:
/// @x_advance: how much the line advances after drawing this glyph when setting
///             text in horizontal direction.
/// @y_advance: how much the line advances after drawing this glyph when setting
///             text in vertical direction.
/// @x_offset: how much the glyph moves on the X-axis before drawing it, this
///            should not affect how much the line advances.
/// @y_offset: how much the glyph moves on the Y-axis before drawing it, this
///            should not affect how much the line advances.
///
/// The `hb_glyph_position_t` is the structure that holds the positions of the
/// glyph in both horizontal and vertical directions. All positions in
/// `hb_glyph_position_t` are relative to the current point.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_glyph_position_t {
    pub x_advance: hb_position_t,
    pub y_advance: hb_position_t,
    pub x_offset: hb_position_t,
    pub y_offset: hb_position_t,
    pub var: hb_var_int_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_position_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_glyph_position_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_glyph_position_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_glyph_position_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_glyph_position_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_position_t>())).x_advance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(x_advance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_position_t>())).y_advance as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(y_advance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_position_t>())).x_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(x_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_position_t>())).y_offset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(y_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_glyph_position_t>())).var as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(var)
        )
    );
}
/// hb_segment_properties_t:
/// @direction: the `hb_direction_t` of the buffer, see hb_buffer_set_direction().
/// @script: the `hb_script_t` of the buffer, see hb_buffer_set_script().
/// @language: the `hb_language_t` of the buffer, see hb_buffer_set_language().
///
/// The structure that holds various text properties of an `hb_buffer_t`. Can be
/// set and retrieved using hb_buffer_set_segment_properties() and
/// hb_buffer_get_segment_properties(), respectively.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_segment_properties_t {
    pub direction: hb_direction_t,
    pub script: hb_script_t,
    pub language: hb_language_t,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub reserved2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_hb_segment_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_segment_properties_t>(),
        32usize,
        concat!("Size of: ", stringify!(hb_segment_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_segment_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hb_segment_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hb_segment_properties_t>())).direction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_segment_properties_t>())).script as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(script)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hb_segment_properties_t>())).language as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(language)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hb_segment_properties_t>())).reserved1 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hb_segment_properties_t>())).reserved2 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(reserved2)
        )
    );
}
extern "C" {
    pub fn hb_segment_properties_equal(
        a: *const hb_segment_properties_t,
        b: *const hb_segment_properties_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_segment_properties_hash(p: *const hb_segment_properties_t) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_buffer_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_buffer_create() -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_get_empty() -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_reference(buffer: *mut hb_buffer_t) -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_destroy(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_set_user_data(
        buffer: *mut hb_buffer_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_get_user_data(
        buffer: *mut hb_buffer_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(u32)]
#[repr(C)]
/// hb_buffer_content_type_t:
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BufferContentType {
    /// Initial value for new buffer.
    Invalid = 0,
    /// The buffer contains input characters (before shaping).
    Unicode = 1,
    /// The buffer contains output glyphs (after shaping).
    Glyphs = 2,
}
pub type hb_buffer_content_type_t = BufferContentType;
extern "C" {
    pub fn hb_buffer_set_content_type(
        buffer: *mut hb_buffer_t,
        content_type: hb_buffer_content_type_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_content_type(buffer: *mut hb_buffer_t) -> hb_buffer_content_type_t;
}
extern "C" {
    pub fn hb_buffer_set_unicode_funcs(
        buffer: *mut hb_buffer_t,
        unicode_funcs: *mut hb_unicode_funcs_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_unicode_funcs(buffer: *mut hb_buffer_t) -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_buffer_set_direction(buffer: *mut hb_buffer_t, direction: hb_direction_t);
}
extern "C" {
    pub fn hb_buffer_get_direction(buffer: *mut hb_buffer_t) -> hb_direction_t;
}
extern "C" {
    pub fn hb_buffer_set_script(buffer: *mut hb_buffer_t, script: hb_script_t);
}
extern "C" {
    pub fn hb_buffer_get_script(buffer: *mut hb_buffer_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_buffer_set_language(buffer: *mut hb_buffer_t, language: hb_language_t);
}
extern "C" {
    pub fn hb_buffer_get_language(buffer: *mut hb_buffer_t) -> hb_language_t;
}
extern "C" {
    pub fn hb_buffer_set_segment_properties(
        buffer: *mut hb_buffer_t,
        props: *const hb_segment_properties_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_segment_properties(
        buffer: *mut hb_buffer_t,
        props: *mut hb_segment_properties_t,
    );
}
extern "C" {
    pub fn hb_buffer_guess_segment_properties(buffer: *mut hb_buffer_t);
}
#[repr(u32)]
#[repr(C)]
/// hb_buffer_flags_t:
/// @HB_BUFFER_FLAG_DEFAULT: the default buffer flag.
/// @HB_BUFFER_FLAG_BOT: flag indicating that special handling of the beginning
///                      of text paragraph can be applied to this buffer. Should usually
///                      be set, unless you are passing to the buffer only part
///                      of the text without the full context.
/// @HB_BUFFER_FLAG_EOT: flag indicating that special handling of the end of text
///                      paragraph can be applied to this buffer, similar to
///                      @HB_BUFFER_FLAG_EOT.
/// @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES:
///                      flag indication that character with Default_Ignorable
///                      Unicode property should use the corresponding glyph
///                      from the font, instead of hiding them (currently done
///                      by replacing them with the space glyph and zeroing the
///                      advance width.)
///
/// Since: 0.9.20
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_buffer_flags_t {
    HB_BUFFER_FLAG_DEFAULT = 0,
    HB_BUFFER_FLAG_BOT = 1,
    HB_BUFFER_FLAG_EOT = 2,
    HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES = 4,
}
extern "C" {
    pub fn hb_buffer_set_flags(buffer: *mut hb_buffer_t, flags: hb_buffer_flags_t);
}
extern "C" {
    pub fn hb_buffer_get_flags(buffer: *mut hb_buffer_t) -> hb_buffer_flags_t;
}
pub const HB_BUFFER_CLUSTER_LEVEL_DEFAULT: BufferClusterLevel =
    BufferClusterLevel::MonotoneGraphemes;
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BufferClusterLevel {
    MonotoneGraphemes = 0,
    MonotoneCharacters = 1,
    Characters = 2,
}
pub type hb_buffer_cluster_level_t = BufferClusterLevel;
extern "C" {
    pub fn hb_buffer_set_cluster_level(
        buffer: *mut hb_buffer_t,
        cluster_level: hb_buffer_cluster_level_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_cluster_level(buffer: *mut hb_buffer_t) -> hb_buffer_cluster_level_t;
}
extern "C" {
    pub fn hb_buffer_set_replacement_codepoint(
        buffer: *mut hb_buffer_t,
        replacement: hb_codepoint_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_replacement_codepoint(buffer: *mut hb_buffer_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_buffer_reset(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_clear_contents(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_pre_allocate(
        buffer: *mut hb_buffer_t,
        size: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_allocation_successful(buffer: *mut hb_buffer_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_reverse(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_reverse_range(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_buffer_reverse_clusters(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_add(
        buffer: *mut hb_buffer_t,
        codepoint: hb_codepoint_t,
        cluster: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_buffer_add_utf8(
        buffer: *mut hb_buffer_t,
        text: *const ::std::os::raw::c_char,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_utf16(
        buffer: *mut hb_buffer_t,
        text: *const u16,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_utf32(
        buffer: *mut hb_buffer_t,
        text: *const u32,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_latin1(
        buffer: *mut hb_buffer_t,
        text: *const u8,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_codepoints(
        buffer: *mut hb_buffer_t,
        text: *const hb_codepoint_t,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_append(
        buffer: *mut hb_buffer_t,
        source: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_buffer_set_length(
        buffer: *mut hb_buffer_t,
        length: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_get_length(buffer: *mut hb_buffer_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_get_glyph_infos(
        buffer: *mut hb_buffer_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *mut hb_glyph_info_t;
}
extern "C" {
    pub fn hb_buffer_get_glyph_positions(
        buffer: *mut hb_buffer_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *mut hb_glyph_position_t;
}
extern "C" {
    pub fn hb_buffer_normalize_glyphs(buffer: *mut hb_buffer_t);
}
#[repr(u32)]
#[repr(C)]
/// hb_buffer_serialize_flags_t:
/// @HB_BUFFER_SERIALIZE_FLAG_DEFAULT: serialize glyph names, clusters and positions.
/// @HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS: do not serialize glyph cluster.
/// @HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS: do not serialize glyph position information.
/// @HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES: do no serialize glyph name.
/// @HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS: serialize glyph extents.
///
/// Flags that control what glyph information are serialized in hb_buffer_serialize_glyphs().
///
/// Since: 0.9.20
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_buffer_serialize_flags_t {
    HB_BUFFER_SERIALIZE_FLAG_DEFAULT = 0,
    HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS = 1,
    HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS = 2,
    HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES = 4,
    HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS = 8,
    HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS = 16,
}
#[repr(u32)]
#[repr(C)]
/// hb_buffer_serialize_format_t:
/// The buffer serialization and de-serialization format used in
/// hb_buffer_serialize_glyphs() and hb_buffer_deserialize_glyphs().
///
/// Since: 0.9.2
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BufferSerializeFormat {
    /// A human-readable, plain text format.
    Text = 1413830740,
    /// A machine-readable JSON format.
    JSON = 1246973774,
    /// Invalid format
    Invalid = 0,
}
pub type hb_buffer_serialize_format_t = BufferSerializeFormat;
extern "C" {
    pub fn hb_buffer_serialize_format_from_string(
        str: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_buffer_serialize_format_t;
}
extern "C" {
    pub fn hb_buffer_serialize_format_to_string(
        format: hb_buffer_serialize_format_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_buffer_serialize_list_formats() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_buffer_serialize_glyphs(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_uint,
        buf_consumed: *mut ::std::os::raw::c_uint,
        font: *mut hb_font_t,
        format: hb_buffer_serialize_format_t,
        flags: hb_buffer_serialize_flags_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_deserialize_glyphs(
        buffer: *mut hb_buffer_t,
        buf: *const ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        end_ptr: *mut *const ::std::os::raw::c_char,
        font: *mut hb_font_t,
        format: hb_buffer_serialize_format_t,
    ) -> hb_bool_t;
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_buffer_diff_flags_t {
    HB_BUFFER_DIFF_FLAG_EQUAL = 0,
    HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH = 1,
    HB_BUFFER_DIFF_FLAG_LENGTH_MISMATCH = 2,
    HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT = 4,
    HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT = 8,
    HB_BUFFER_DIFF_FLAG_CODEPOINT_MISMATCH = 16,
    HB_BUFFER_DIFF_FLAG_CLUSTER_MISMATCH = 32,
    HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH = 64,
    HB_BUFFER_DIFF_FLAG_POSITION_MISMATCH = 128,
}
extern "C" {
    pub fn hb_buffer_diff(
        buffer: *mut hb_buffer_t,
        reference: *mut hb_buffer_t,
        dottedcircle_glyph: hb_codepoint_t,
        position_fuzz: ::std::os::raw::c_uint,
    ) -> hb_buffer_diff_flags_t;
}
pub type hb_buffer_message_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut hb_buffer_t,
        font: *mut hb_font_t,
        message: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
extern "C" {
    pub fn hb_buffer_set_message_func(
        buffer: *mut hb_buffer_t,
        func: hb_buffer_message_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_set_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_set_create() -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_get_empty() -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_reference(set: *mut hb_set_t) -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_destroy(set: *mut hb_set_t);
}
extern "C" {
    pub fn hb_set_set_user_data(
        set: *mut hb_set_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_get_user_data(
        set: *mut hb_set_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_set_allocation_successful(set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_clear(set: *mut hb_set_t);
}
extern "C" {
    pub fn hb_set_is_empty(set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_has(set: *const hb_set_t, codepoint: hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_add(set: *mut hb_set_t, codepoint: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_add_range(set: *mut hb_set_t, first: hb_codepoint_t, last: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_del(set: *mut hb_set_t, codepoint: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_del_range(set: *mut hb_set_t, first: hb_codepoint_t, last: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_is_equal(set: *const hb_set_t, other: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_set(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_union(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_intersect(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_subtract(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_symmetric_difference(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_get_population(set: *const hb_set_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_set_get_min(set: *const hb_set_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_set_get_max(set: *const hb_set_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_set_next(set: *const hb_set_t, codepoint: *mut hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_next_range(
        set: *const hb_set_t,
        first: *mut hb_codepoint_t,
        last: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape(
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_shape_full(
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_list_shapers() -> *mut *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_shape_plan_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_shape_plan_create(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create_cached(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create2(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        coords: *const ::std::os::raw::c_int,
        num_coords: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create_cached2(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        coords: *const ::std::os::raw::c_int,
        num_coords: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_get_empty() -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_reference(shape_plan: *mut hb_shape_plan_t) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_destroy(shape_plan: *mut hb_shape_plan_t);
}
extern "C" {
    pub fn hb_shape_plan_set_user_data(
        shape_plan: *mut hb_shape_plan_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_plan_get_user_data(
        shape_plan: *mut hb_shape_plan_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_shape_plan_execute(
        shape_plan: *mut hb_shape_plan_t,
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_plan_get_shaper(
        shape_plan: *mut hb_shape_plan_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_version(
        major: *mut ::std::os::raw::c_uint,
        minor: *mut ::std::os::raw::c_uint,
        micro: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_version_atleast(
        major: ::std::os::raw::c_uint,
        minor: ::std::os::raw::c_uint,
        micro: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_font_set_funcs(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_ot_tags_from_script(
        script: hb_script_t,
        script_tag_1: *mut hb_tag_t,
        script_tag_2: *mut hb_tag_t,
    );
}
extern "C" {
    pub fn hb_ot_tag_to_script(tag: hb_tag_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_ot_tag_from_language(language: hb_language_t) -> hb_tag_t;
}
extern "C" {
    pub fn hb_ot_tag_to_language(tag: hb_tag_t) -> hb_language_t;
}
extern "C" {
    pub fn hb_ot_layout_has_glyph_classes(face: *mut hb_face_t) -> hb_bool_t;
}
#[repr(u32)]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OTLayoutGlyphClass {
    Unclassified = 0,
    BaseGlyph = 1,
    Ligature = 2,
    Mark = 3,
    Component = 4,
}
pub type hb_ot_layout_glyph_class_t = OTLayoutGlyphClass;
extern "C" {
    pub fn hb_ot_layout_get_glyph_class(
        face: *mut hb_face_t,
        glyph: hb_codepoint_t,
    ) -> hb_ot_layout_glyph_class_t;
}
extern "C" {
    pub fn hb_ot_layout_get_glyphs_in_class(
        face: *mut hb_face_t,
        klass: hb_ot_layout_glyph_class_t,
        glyphs: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_get_attach_points(
        face: *mut hb_face_t,
        glyph: hb_codepoint_t,
        start_offset: ::std::os::raw::c_uint,
        point_count: *mut ::std::os::raw::c_uint,
        point_array: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_get_ligature_carets(
        font: *mut hb_font_t,
        direction: hb_direction_t,
        glyph: hb_codepoint_t,
        start_offset: ::std::os::raw::c_uint,
        caret_count: *mut ::std::os::raw::c_uint,
        caret_array: *mut hb_position_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_table_get_script_tags(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        start_offset: ::std::os::raw::c_uint,
        script_count: *mut ::std::os::raw::c_uint,
        script_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_table_find_script(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_tag: hb_tag_t,
        script_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_table_choose_script(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_tags: *const hb_tag_t,
        script_index: *mut ::std::os::raw::c_uint,
        chosen_script: *mut hb_tag_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_table_get_feature_tags(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        start_offset: ::std::os::raw::c_uint,
        feature_count: *mut ::std::os::raw::c_uint,
        feature_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_script_get_language_tags(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        language_count: *mut ::std::os::raw::c_uint,
        language_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_script_find_language(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_tag: hb_tag_t,
        language_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_language_get_required_feature_index(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        feature_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_language_get_required_feature(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        feature_index: *mut ::std::os::raw::c_uint,
        feature_tag: *mut hb_tag_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_language_get_feature_indexes(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        feature_count: *mut ::std::os::raw::c_uint,
        feature_indexes: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_language_get_feature_tags(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        feature_count: *mut ::std::os::raw::c_uint,
        feature_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_language_find_feature(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        script_index: ::std::os::raw::c_uint,
        language_index: ::std::os::raw::c_uint,
        feature_tag: hb_tag_t,
        feature_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_feature_get_lookups(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        feature_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        lookup_count: *mut ::std::os::raw::c_uint,
        lookup_indexes: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_table_get_lookup_count(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_collect_lookups(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        scripts: *const hb_tag_t,
        languages: *const hb_tag_t,
        features: *const hb_tag_t,
        lookup_indexes: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_lookup_collect_glyphs(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        lookup_index: ::std::os::raw::c_uint,
        glyphs_before: *mut hb_set_t,
        glyphs_input: *mut hb_set_t,
        glyphs_after: *mut hb_set_t,
        glyphs_output: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_table_find_feature_variations(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        coords: *const ::std::os::raw::c_int,
        num_coords: ::std::os::raw::c_uint,
        variations_index: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_feature_with_variations_get_lookups(
        face: *mut hb_face_t,
        table_tag: hb_tag_t,
        feature_index: ::std::os::raw::c_uint,
        variations_index: ::std::os::raw::c_uint,
        start_offset: ::std::os::raw::c_uint,
        lookup_count: *mut ::std::os::raw::c_uint,
        lookup_indexes: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_layout_has_substitution(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_lookup_would_substitute(
        face: *mut hb_face_t,
        lookup_index: ::std::os::raw::c_uint,
        glyphs: *const hb_codepoint_t,
        glyphs_length: ::std::os::raw::c_uint,
        zero_context: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_lookup_substitute_closure(
        face: *mut hb_face_t,
        lookup_index: ::std::os::raw::c_uint,
        glyphs: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_layout_has_positioning(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_layout_get_size_params(
        face: *mut hb_face_t,
        design_size: *mut ::std::os::raw::c_uint,
        subfamily_id: *mut ::std::os::raw::c_uint,
        subfamily_name_id: *mut ::std::os::raw::c_uint,
        range_start: *mut ::std::os::raw::c_uint,
        range_end: *mut ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
#[repr(u32)]
#[repr(C)]
/// hb_ot_math_constant_t:
///
/// Since: 1.3.3
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OTMathConstant {
    ScriptPercentScaleDown = 0,
    ScriptScriptPercentScaleDown = 1,
    DelimitedSubFormulaMinHeight = 2,
    DisplayOperatorMinHeight = 3,
    MathLeading = 4,
    AxisHeight = 5,
    AccentBaseHeight = 6,
    FlattenedAccentBaseHeight = 7,
    SubscriptShiftDown = 8,
    SubscriptTopMax = 9,
    SubscriptBaselineDropMin = 10,
    SuperscriptShiftUp = 11,
    SuperscriptShiftUpCramped = 12,
    SuperscriptBottomMin = 13,
    SuperscriptBaselineDropMax = 14,
    SubSuperscriptGapMin = 15,
    SuperscriptBottomMaxWithSubscript = 16,
    SpaceAfterScript = 17,
    UpperLimitGapMin = 18,
    UpperLimitBaselineRiseMin = 19,
    LowerLimitGapMin = 20,
    LowerLimitBaselineDropMin = 21,
    StackTopShiftUp = 22,
    StackTopDisplayStyleShiftUp = 23,
    StackBottomShiftDown = 24,
    StackBottomDisplayStyleShiftDown = 25,
    StackGapMin = 26,
    StackDisplayStyleGapMin = 27,
    StretchStackTopShiftUp = 28,
    StretchStackBottomShiftDown = 29,
    StretchStackGapAboveMin = 30,
    StretchStackGapBelowMin = 31,
    FractionNumeratorShiftUp = 32,
    FractionNumeratorDisplayStyleShiftUp = 33,
    FractionDenominatorShiftDown = 34,
    FractionDenominatorDisplayStyleShiftDown = 35,
    FractionNumeratorGapMin = 36,
    FractionNumDisplayStyleGapMin = 37,
    FractionRuleThickness = 38,
    FractionDenominatorGapMin = 39,
    FractionDenomDisplayStyleGapMin = 40,
    SkewedFractionHorizontalGap = 41,
    SkewedFractionVerticalGap = 42,
    OverbarVerticalGap = 43,
    OverbarRuleThickness = 44,
    OverbarExtraAscender = 45,
    UnderbarVerticalGap = 46,
    UnderbarRuleThickness = 47,
    UnderbarExtraDescender = 48,
    RadicalVerticalGap = 49,
    RadicalDisplayStyleVerticalGap = 50,
    RadicalRuleThickness = 51,
    RadicalExtraAscender = 52,
    RadicalKernBeforeDegree = 53,
    RadicalKernAfterDegree = 54,
    RadicalDegreeBottomRaisePercent = 55,
}
pub type hb_ot_math_constant_t = OTMathConstant;
#[repr(u32)]
#[repr(C)]
/// hb_ot_math_kern_t:
///
/// Since: 1.3.3
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OTMathKern {
    TopRight = 0,
    TopLeft = 1,
    BottomRight = 2,
    BottomLeft = 3,
}
pub type hb_ot_math_kern_t = OTMathKern;
/// hb_ot_math_glyph_variant_t:
///
/// Since: 1.3.3
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_math_glyph_variant_t {
    pub glyph: hb_codepoint_t,
    pub advance: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_ot_math_glyph_variant_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_ot_math_glyph_variant_t>(),
        8usize,
        concat!("Size of: ", stringify!(hb_ot_math_glyph_variant_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_math_glyph_variant_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_math_glyph_variant_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hb_ot_math_glyph_variant_t>())).glyph as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_variant_t),
            "::",
            stringify!(glyph)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hb_ot_math_glyph_variant_t>())).advance as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_variant_t),
            "::",
            stringify!(advance)
        )
    );
}
#[repr(u32)]
#[repr(C)]
/// hb_ot_math_glyph_part_flags_t:
///
/// Since: 1.3.3
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OTMathGlyphPartFlags {
    Extender = 1,
}
pub type hb_ot_math_glyph_part_flags_t = OTMathGlyphPartFlags;
/// hb_ot_math_glyph_part_t:
///
/// Since: 1.3.3
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_math_glyph_part_t {
    pub glyph: hb_codepoint_t,
    pub start_connector_length: hb_position_t,
    pub end_connector_length: hb_position_t,
    pub full_advance: hb_position_t,
    pub flags: hb_ot_math_glyph_part_flags_t,
}
#[test]
fn bindgen_test_layout_hb_ot_math_glyph_part_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_ot_math_glyph_part_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_ot_math_glyph_part_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_math_glyph_part_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_math_glyph_part_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_ot_math_glyph_part_t>())).glyph as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_part_t),
            "::",
            stringify!(glyph)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hb_ot_math_glyph_part_t>())).start_connector_length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_part_t),
            "::",
            stringify!(start_connector_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hb_ot_math_glyph_part_t>())).end_connector_length as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_part_t),
            "::",
            stringify!(end_connector_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hb_ot_math_glyph_part_t>())).full_advance as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_part_t),
            "::",
            stringify!(full_advance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_ot_math_glyph_part_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_math_glyph_part_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn hb_ot_math_has_data(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_math_get_constant(
        font: *mut hb_font_t,
        constant: hb_ot_math_constant_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_italics_correction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_top_accent_attachment(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_is_glyph_extended_shape(
        face: *mut hb_face_t,
        glyph: hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_kerning(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        kern: hb_ot_math_kern_t,
        correction_height: hb_position_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_variants(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        start_offset: ::std::os::raw::c_uint,
        variants_count: *mut ::std::os::raw::c_uint,
        variants: *mut hb_ot_math_glyph_variant_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_math_get_min_connector_overlap(
        font: *mut hb_font_t,
        direction: hb_direction_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_ot_math_get_glyph_assembly(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        start_offset: ::std::os::raw::c_uint,
        parts_count: *mut ::std::os::raw::c_uint,
        parts: *mut hb_ot_math_glyph_part_t,
        italics_correction: *mut hb_position_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_shape_glyphs_closure(
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
        glyphs: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_ot_shape_plan_collect_lookups(
        shape_plan: *mut hb_shape_plan_t,
        table_tag: hb_tag_t,
        lookup_indexes: *mut hb_set_t,
    );
}
/// hb_ot_var_axis_t:
///
/// Since: 1.4.2
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_ot_var_axis_t {
    pub tag: hb_tag_t,
    pub name_id: ::std::os::raw::c_uint,
    pub min_value: f32,
    pub default_value: f32,
    pub max_value: f32,
}
#[test]
fn bindgen_test_layout_hb_ot_var_axis_t() {
    assert_eq!(
        ::std::mem::size_of::<hb_ot_var_axis_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_ot_var_axis_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_ot_var_axis_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_ot_var_axis_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_ot_var_axis_t>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_ot_var_axis_t>())).name_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_t),
            "::",
            stringify!(name_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_ot_var_axis_t>())).min_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_t),
            "::",
            stringify!(min_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_ot_var_axis_t>())).default_value as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_t),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hb_ot_var_axis_t>())).max_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_ot_var_axis_t),
            "::",
            stringify!(max_value)
        )
    );
}
extern "C" {
    pub fn hb_ot_var_has_data(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_var_get_axis_count(face: *mut hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_var_get_axes(
        face: *mut hb_face_t,
        start_offset: ::std::os::raw::c_uint,
        axes_count: *mut ::std::os::raw::c_uint,
        axes_array: *mut hb_ot_var_axis_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_ot_var_find_axis(
        face: *mut hb_face_t,
        axis_tag: hb_tag_t,
        axis_index: *mut ::std::os::raw::c_uint,
        axis_info: *mut hb_ot_var_axis_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_ot_var_normalize_variations(
        face: *mut hb_face_t,
        variations: *const hb_variation_t,
        variations_length: ::std::os::raw::c_uint,
        coords: *mut ::std::os::raw::c_int,
        coords_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_ot_var_normalize_coords(
        face: *mut hb_face_t,
        coords_length: ::std::os::raw::c_uint,
        design_coords: *const f32,
        normalized_coords: *mut ::std::os::raw::c_int,
    );
}
